<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversor a Caricatura y Vector</title>
    <!-- Incluye Tailwind CSS para el estilo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <!-- Main container -->
    <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg w-full max-w-4xl text-center">
        <h1 class="text-3xl font-bold mb-4 text-gray-800">Convierte tu Imagen a Caricatura y Líneas</h1>
        <p class="text-gray-600 mb-6">Selecciona una imagen (JPG o PNG) y aplica diferentes efectos.</p>

        <!-- File input and action buttons -->
        <div class="mb-6 flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
            <input type="file" id="imageInput" accept="image/jpeg, image/png" class="block w-full md:w-auto text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-50 file:text-blue-700
                hover:file:bg-blue-100
            "/>
            <div class="flex flex-col space-y-2 md:flex-row md:space-y-0 md:space-x-4">
                <button id="convertBtn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-full shadow-md hover:bg-blue-700 transition duration-300 transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    Convertir a 8 Colores
                </button>
                <button id="linesBtn" class="bg-green-600 text-white font-bold py-2 px-6 rounded-full shadow-md hover:bg-green-700 transition duration-300 transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    Convertir a Líneas
                </button>
                <button id="svgBtn" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-full shadow-md hover:bg-purple-700 transition duration-300 transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    Descargar SVG
                </button>
            </div>
        </div>

        <!-- Status/Message Area -->
        <p id="statusMessage" class="mt-6 text-sm text-red-500"></p>

        <!-- Image display section -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-8">
            <!-- Original Image -->
            <div class="flex flex-col items-center">
                <h3 class="text-lg font-semibold text-gray-700 mb-2">Original</h3>
                <div class="w-full h-auto max-h-[400px] overflow-hidden rounded-lg shadow-md border-2 border-gray-200">
                    <img id="originalImage" src="https://placehold.co/600x400/E5E7EB/4B5563?text=Imagen+Original" alt="Original Image" class="w-full h-full object-contain">
                </div>
            </div>

            <!-- Converted to 8 Colors Image -->
            <div class="flex flex-col items-center">
                <h3 class="text-lg font-semibold text-gray-700 mb-2">Caricatura (8 colores)</h3>
                <div class="w-full h-auto max-h-[400px] overflow-hidden rounded-lg shadow-md border-2 border-gray-200">
                    <img id="convertedImage" src="https://placehold.co/600x400/E5E7EB/4B5563?text=Convertir+Primero" alt="Converted Image" class="w-full h-full object-contain">
                </div>
            </div>

            <!-- Converted to Lines Image -->
            <div class="flex flex-col items-center">
                <h3 class="text-lg font-semibold text-gray-700 mb-2">Dibujo a Líneas</h3>
                <div class="w-full h-auto max-h-[400px] overflow-hidden rounded-lg shadow-md border-2 border-gray-200">
                    <img id="linesImage" src="https://placehold.co/600x400/E5E7EB/4B5563?text=Convertir+a+Líneas" alt="Lines Image" class="w-full h-full object-contain">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const imageInput = document.getElementById('imageInput');
        const convertBtn = document.getElementById('convertBtn');
        const linesBtn = document.getElementById('linesBtn');
        const svgBtn = document.getElementById('svgBtn');
        const originalImage = document.getElementById('originalImage');
        const convertedImage = document.getElementById('convertedImage');
        const linesImage = document.getElementById('linesImage');
        const statusMessage = document.getElementById('statusMessage');

        let originalImageFile = null;

        // Function to handle image selection
        imageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                originalImageFile = file;
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage.src = e.target.result;
                    // Reset converted images
                    convertedImage.src = "https://placehold.co/600x400/E5E7EB/4B5563?text=Convertir+Primero";
                    linesImage.src = "https://placehold.co/600x400/E5E7EB/4B5563?text=Convertir+a+Líneas";
                    statusMessage.textContent = '';
                    linesBtn.disabled = true;
                    svgBtn.disabled = true;
                };
                reader.onerror = () => {
                    statusMessage.textContent = 'Error al leer el archivo.';
                };
                reader.readAsDataURL(file);
            }
        });

        // Function to find the closest color in a palette
        function findClosestColor(r, g, b, palette) {
            let closestColor = null;
            let minDistance = Infinity;

            for (const color of palette) {
                const [pr, pg, pb] = color;
                const distance = Math.sqrt(
                    Math.pow(r - pr, 2) + Math.pow(g - pg, 2) + Math.pow(b - pb, 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            return closestColor;
        }

        // Function to perform the image conversion to 8 colors
        convertBtn.addEventListener('click', () => {
            if (!originalImageFile) {
                statusMessage.textContent = 'Por favor, selecciona una imagen primero.';
                return;
            }

            statusMessage.textContent = 'Convirtiendo a 8 colores...';
            convertBtn.disabled = true;
            linesBtn.disabled = true;
            svgBtn.disabled = true;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                const palette = [
                    [0, 0, 0], [255, 255, 255], [255, 0, 0], [0, 255, 0], 
                    [0, 0, 255], [255, 255, 0], [0, 255, 255], [255, 0, 255]
                ];

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const closestColor = findClosestColor(r, g, b, palette);
                    data[i] = closestColor[0];
                    data[i + 1] = closestColor[1];
                    data[i + 2] = closestColor[2];
                }

                ctx.putImageData(imageData, 0, 0);
                convertedImage.src = canvas.toDataURL('image/png');
                statusMessage.textContent = '¡Conversión a 8 colores completa!';
                convertBtn.disabled = false;
                linesBtn.disabled = false;
                svgBtn.disabled = false;
            };

            img.onerror = () => {
                statusMessage.textContent = 'Error al cargar la imagen.';
                convertBtn.disabled = false;
            };
            img.src = originalImage.src;
        });

        // Function to convert the processed 8-color image to lines
        linesBtn.addEventListener('click', () => {
            if (convertedImage.src.includes('Convertir+Primero')) {
                statusMessage.textContent = 'Por favor, convierte la imagen a 8 colores primero.';
                return;
            }

            statusMessage.textContent = 'Convirtiendo a líneas...';
            linesBtn.disabled = true;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                const linesCanvas = document.createElement('canvas');
                const linesCtx = linesCanvas.getContext('2d');
                linesCanvas.width = img.width;
                linesCanvas.height = img.height;
                linesCtx.fillStyle = '#FFFFFF';
                linesCtx.fillRect(0, 0, linesCanvas.width, linesCanvas.height);

                const lineThickness = 3;
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const i = (y * canvas.width + x) * 4;
                        
                        const r1 = data[i];
                        const g1 = data[i + 1];
                        const b1 = data[i + 2];
                        
                        const rightIndex = (y * canvas.width + (x + 1)) * 4;
                        const bottomIndex = ((y + 1) * canvas.width + x) * 4;
                        
                        let isEdge = false;
                        
                        if (x < canvas.width - 1) {
                            const r2 = data[rightIndex];
                            const g2 = data[rightIndex + 1];
                            const b2 = data[rightIndex + 2];
                            if (r1 !== r2 || g1 !== g2 || b1 !== b2) {
                                isEdge = true;
                            }
                        }
                        
                        if (y < canvas.height - 1) {
                            const r2 = data[bottomIndex];
                            const g2 = data[bottomIndex + 1];
                            const b2 = data[bottomIndex + 2];
                            if (r1 !== r2 || g1 !== g2 || b1 !== b2) {
                                isEdge = true;
                            }
                        }
                        
                        if (isEdge) {
                            linesCtx.fillStyle = `rgb(${r1},${g1},${b1})`;
                            linesCtx.fillRect(x, y, lineThickness, lineThickness);
                        }
                    }
                }
                
                linesImage.src = linesCanvas.toDataURL('image/png');
                statusMessage.textContent = '¡Conversión a líneas completa!';
                linesBtn.disabled = false;
            };

            img.onerror = () => {
                statusMessage.textContent = 'Error al cargar la imagen procesada.';
                linesBtn.disabled = false;
            };
            img.src = convertedImage.src;
        });

        // Function to apply a 3x3 mode filter
        function applyModeFilter(imageData, width, height) {
            const inputData = new Uint8ClampedArray(imageData.data); // Use a copy
            const outputData = imageData.data;
            const size = 3;
            const halfSize = Math.floor(size / 2);

            for (let y = halfSize; y < height - halfSize; y++) {
                for (let x = halfSize; x < width - halfSize; x++) {
                    const neighborhood = [];
                    // Collect all colors in the 3x3 neighborhood
                    for (let ny = -halfSize; ny <= halfSize; ny++) {
                        for (let nx = -halfSize; nx <= halfSize; nx++) {
                            const neighborIndex = ((y + ny) * width + (x + nx)) * 4;
                            const r = inputData[neighborIndex];
                            const g = inputData[neighborIndex + 1];
                            const b = inputData[neighborIndex + 2];
                            neighborhood.push(`${r},${g},${b}`);
                        }
                    }

                    // Find the most frequent color (mode)
                    const counts = {};
                    let maxCount = 0;
                    let mostFrequentColor = '0,0,0';

                    for (const color of neighborhood) {
                        counts[color] = (counts[color] || 0) + 1;
                        if (counts[color] > maxCount) {
                            maxCount = counts[color];
                            mostFrequentColor = color;
                        }
                    }

                    const [r, g, b] = mostFrequentColor.split(',').map(Number);
                    const centerIndex = (y * width + x) * 4;
                    outputData[centerIndex] = r;
                    outputData[centerIndex + 1] = g;
                    outputData[centerIndex + 2] = b;
                }
            }
            return imageData;
        }

        // Function to convert the processed 8-color image to SVG and download it
        svgBtn.addEventListener('click', () => {
            if (convertedImage.src.includes('Convertir+Primero')) {
                statusMessage.textContent = 'Por favor, convierte la imagen a 8 colores primero.';
                return;
            }

            statusMessage.textContent = 'Aplicando filtro y generando SVG...';
            svgBtn.disabled = true;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Apply the 3x3 mode filter to simplify the colors
                imageData = applyModeFilter(imageData, canvas.width, canvas.height);

                const data = imageData.data;
                const svgWidth = img.width;
                const svgHeight = img.height;
                let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;

                // Draw a white background
                svgContent += `<rect width="100%" height="100%" fill="#FFFFFF"/>`;

                // Simplified edge detection and SVG path creation
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const i = (y * canvas.width + x) * 4;
                        
                        const r1 = data[i];
                        const g1 = data[i + 1];
                        const b1 = data[i + 2];
                        
                        const rightIndex = (y * canvas.width + (x + 1)) * 4;
                        const bottomIndex = ((y + 1) * canvas.width + x) * 4;
                        
                        let isEdge = false;
                        
                        if (x < canvas.width - 1) {
                            const r2 = data[rightIndex];
                            const g2 = data[rightIndex + 1];
                            const b2 = data[rightIndex + 2];
                            if (r1 !== r2 || g1 !== g2 || b1 !== b2) {
                                isEdge = true;
                            }
                        }
                        
                        if (y < canvas.height - 1) {
                            const r2 = data[bottomIndex];
                            const g2 = data[bottomIndex + 1];
                            const b2 = data[bottomIndex + 2];
                            if (r1 !== r2 || g1 !== g2 || b1 !== b2) {
                                isEdge = true;
                            }
                        }
                        
                        if (isEdge) {
                            // Create a small colored rectangle for each edge pixel
                            const hexColor = '#' +
                                ('0' + r1.toString(16)).slice(-2) +
                                ('0' + g1.toString(16)).slice(-2) +
                                ('0' + b1.toString(16)).slice(-2);
                            svgContent += `<rect x="${x}" y="${y}" width="3" height="3" fill="${hexColor}"/>`;
                        }
                    }
                }
                
                svgContent += `</svg>`;

                // Download the SVG file
                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'caricatura_simplificada.svg';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusMessage.textContent = '¡Archivo SVG descargado!';
                svgBtn.disabled = false;
            };
            img.onerror = () => {
                statusMessage.textContent = 'Error al cargar la imagen procesada para SVG.';
                svgBtn.disabled = false;
            };
            img.src = convertedImage.src;
        });

    </script>
</body>
</html>
